#!/bin/bash
# vim: set ft=sh fdm=marker ai ts=2 sw=2 tw=79 et:

set -o pipefail
set -o errtrace
set -o nounset
set -o errexit

PROG="nicy"

usage() { #{{{
  cat <<_EOF_
Usage:
  $PROG [(-q|-v)|-n|-s] [-t TYPE|-d|-z] [-c CGROUP|--cpu{QUOTA}] [-u] [-m] CMD [ARGS]…
  $PROG --rebuild
  $PROG -k (rules|types|cgroups) [--from-dir=DIR]

Options:
  -q, --quiet          Be quiet and suppress additional informational output.
  -v, --verbose        Be verbose and display which command is launched.
  -n, --dry-run        Display commands but do not run them.
  -s, --build-script   Build a script that replaces the current commandline,
                       excluding the final arguments, and display it.

  -t, --type=TYPE      Control the set of properties applied. Use 'auto' to sea-
                       rch for the command rule set (default), 'cgroup-only' to
                       remove any property except the cgroup, 'default' or an
                       other defined type TYPE.
  -d, --default        Like '--type=default'. Do not search for a rule.
                       Apply the fallback values from the 'default' type.
  -z, --cgroup-only    Like '--type=cgroup-only'. Unset all other properties.

  -c, --cgroup=CGROUP  Run the command as part of this existing CGROUP.
      --cpu{QUOTA}     Like '--cgroup=cpu{QUOTA}' where QUOTA is an integer that
                       represents a percentage relative to the total CPU time
                       available on all cores.

  -m, --managed        Always run the command in a transient scope.
  -u, --force-cgroup   Run the command as part of an existing cgroup, if any,
                       that matches properties found, when no other cgroup has
                       been set.

      --rebuild        Rebuild the cache and exit.

  -k, --keys=KIND      List known KIND keys.
      --from-dir=DIR   Limit keys search to configuration files from DIR folder.

  -h, --help           Display this help and exit.
_EOF_
} #}}}

error_exit() { #{{{
  echo -e "$PROG: error: ${2:-'unknown error'}" >&2
  exit "${1:-1}"
} #}}}

# The user 's configuration files always get the highest priority.
for dir in "/usr/local/etc" "/etc" "${XDG_CONFIG_HOME:-$HOME/.config}"; do
  [ -f "$dir/$PROG/environment" ] && . "$dir/$PROG/environment"
done

[ ${#NICY_SEARCH_DIRS[@]} -eq 0 ] &&
  NICY_SEARCH_DIRS=("$HOME/.config/$PROG" "/etc/$PROG" "/usr/local/etc/$PROG")

[ -z "$NICY_DATADIR" -o ! -d "$NICY_DATADIR" ] &&
  NICY_DATADIR="/usr/local/share/nicy"

bool() { #{{{
  [ $# -gt 0 ] || return 2
  case "${1,,}" in
    n | no | false | off | 0 | disabled | disabled | nouse) return 1 ;;
    y | yes | true | on | 1 | enabled | enable | use) return 0 ;;
  esac
  return 1
} #}}}

true_or_false() { #{{{
  bool "$1" &&
    echo "true" ||
    echo "false"
} #}}}

# Show what's going on
if [ -n "$NICY_VERBOSE" ]; then
  NICY_VERBOSE=$(true_or_false "$NICY_VERBOSE")
else
  NICY_VERBOSE=false
fi

QUIET=false
VERBOSE=0
bool "$NICY_VERBOSE" &&
  VERBOSE=1
USE_TYPE=auto
USE_CGROUP=null
FORCE_CGROUP=false
ALWAYS_USE_SCOPE=false
DRY_RUN=false
LIST_KEYS=
DIR_KEYS=

SUBCMD=exec

declare -ga search_dirs
for dir in "${NICY_SEARCH_DIRS[@]}"; do
  [ -d "$dir" ] && search_dirs+=($(realpath "$dir"))
done

RUNTIMEDIR="${XDG_RUNTIME_DIR:-/run/user/$UID}/$PROG"
[ ! -d "$RUNTIMEDIR" ] && mkdir -p "$RUNTIMEDIR"
CACHEDIR="${XDG_CACHE_HOME:-$HOME/.cache}/${PROG}"
[ ! -d "$CACHEDIR" ] && mkdir -p "$CACHEDIR"

CGROUPS="$CACHEDIR/cgroups"
CPU_COUNT=$(nproc --all)
TYPES="$CACHEDIR/types"
RULES="$CACHEDIR/rules"
DATABASE="$CACHEDIR/database"


# Functions

JQ_PATH=$(command -v jq)
jq() { $JQ_PATH -M "$@"; }

dump_content() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  [[ "$kind" =~ ^(cgroup|type|rule)$ ]] || return 2
  if [ "$kind" = "rule" ]; then
    depth="-mindepth 2"
    key="name"
  else
    depth="-maxdepth 1"
    key=$kind
  fi
  shift
  for confdir; do
    [ -d "$confdir" ] || continue
    find "${confdir}/" $depth -type f -iname "*.${kind}s" -print | sort -rn |
    xargs sed -E -s -e '/^\s*#/d' -e '/^$/d' \
      -e 's/("'"$key"'"\s*:)/"origin": "'"${confdir//\//\\\/}"'", \1/g'
  done
} #}}}

get_keys() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  shift
  jqscript=$(printf 'include "nicy" ; dump("%s")' "$kind")
  jq -nr -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" \
    --args "$@" \
    |& tee "$volatile" \
    | column -t -s $'\t' | tail -n +2
} #}}}

make_json_cache() { #{{{
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  jqscript=$(printf 'include "nicy" ; make_cache("%s")' "$kind")
  for confdir in "${search_dirs[@]}"; do
    dump_content "$kind" "$confdir" | jq -sc -L "$NICY_DATADIR" "$jqscript"
  done |& tee "$volatile"
} #}}}

make_json_database() { #{{{
  jqargs=()
  pairs=($(printf '"%s":%s' "date" "$(date +"%s")"))
  for kind in "cgroup" "type" "rule"; do
    pairs+=($(printf '"%ss":$%ss' "$kind" "$kind"))
    var="${kind^^}S"
    jqargs+=(--slurpfile "${kind}s" "${!var}")
  done
  jqscript='{'"$( IFS=',' && echo "${pairs[*]}")"'}'
  jq -n "${jqargs[@]}" "$jqscript" >"$DATABASE"
} #}}}

check_or_build_cache() { #{{{
  # TODO: Provide environment variable to always rebuild cache
  do_rebuild=${1:-no}
  for kind in "cgroup" "type" "rule"; do
    var="${kind^^}S"
    dest=${!var}
    if [ ! -f "$dest" ] || bool $do_rebuild; then
      make_json_cache "$kind" >"$dest"
    fi
  done
  if [ ! -f "$DATABASE" ] || bool $do_rebuild; then
    make_json_database
  fi
} #}}}

find_which_cmd() { #{{{
  name=$(basename "$1")
  # Strip suffix, if any
  name=${name%.nicy}
  # Set an absolute path for the final command, trying to prevent loops (for
  # instance, with nested nicy invocations).
  pattern="${HOME}/.*nicy.*" # Match default home path set by some nicy helper
  # Not valid absolute path
  if [ "$1" = "$name" ] ||
    [[ "$(readlink -f $(which "$cmd"))" =~ $pattern ]]; then
    for path in $(which -a "$name"); do
      # Skip path that contains "nicy"
      [[ "$path" =~ $pattern ]] && continue
      cmd=$path
      break
    done
  else
    cmd=$1
  fi
  echo "$cmd"
} #}}}

jsonify() { #{{{
  case "$1" in
    [0-9]* | true | false | null) echo "$1" ;;
    *) echo '"'"$1"'"' ;;
  esac
} #}}}

REQUEST_TEMPLATE='{
  "name": "%s",
  "which_cmd": "%s",
  "option": "%s",
  "use_cgroup": %s,
  "find_matching": %s,
  "use_scope": %s,
  "quiet": %s,
  "verbose": %d,
  "nproc": %d,
  "schedtool": "%s",
  "ionice": "%s"
}'

build_request() { #{{{
  cmd=$(find_which_cmd "$1")
  printf "$REQUEST_TEMPLATE" \
    "$(basename "$cmd")" \
    "$cmd" \
    "${USE_TYPE}" \
    $(jsonify ${USE_CGROUP}) \
    ${FORCE_CGROUP} \
    ${ALWAYS_USE_SCOPE} \
    ${QUIET} \
    ${VERBOSE} \
    $CPU_COUNT \
    "$(LANG=C schedtool $$)" \
    "$(LANG=C ionice -p $$)"
} #}}}

COMMANDS="$RUNTIMEDIR/commands"

get_commands() { #{{{
  jqscript='include "nicy" ; main'
  build_request "$1" | \
    jq -r -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" > "$COMMANDS"
} #}}}

# Parse options
OPTIND=1
while getopts ":-:hsnqvt:c:k:dzmu" option; do #{{{
  case $option in
    -)
      case "$OPTARG" in
        help)
          SUBCMD=usage
          break
          ;;
        rebuild)
          SUBCMD=rebuild
          break
          ;;
        dry-run) DRY_RUN=true ;;
        quiet) QUIET=true ;;
        verbose) VERBOSE=$(($VERBOSE + 1))   ;;
        type=*) # Accepts auto, default, cgroup-only or any known type
          value=${OPTARG#type=}
          [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
            USE_TYPE="${value,,}" ||
            USE_TYPE="$value"
          ;;
        cgroup=*) USE_CGROUP="${OPTARG#cgroup=}" ;;
        default) USE_TYPE="default" ;;
        cgroup-only) USE_TYPE="cgroup-only" ;;
        managed) ALWAYS_USE_SCOPE=true ;;
        force-cgroup) FORCE_CGROUP=true ;;
        cpu*) USE_CGROUP="$OPTARG" ;;
        build-script) SUBCMD=show-script ;;
        keys=*)
          kind=${OPTARG#keys=}
          kind=${kind,,}
          kind=${kind%s}
          case "$kind" in
            rule | type | cgroup)
              SUBCMD=list
              LIST_KEYS=$kind
              ;;
            *) error_exit 1 "not a valid search key '${OPTARG##*=}'." ;;
          esac
          ;;
        from-dir=*)
          [ -z "$LIST_KEYS" ] &&
            error_exit 1 "missing required '--keys' option"
          dir=${OPTARG#from-dir=}
          dir=$(eval echo "$dir")
          [ ! -d "$dir" ] &&
            error_exit 1 "no such directory '$dir'"
          case ":$(IFS=: ; echo "${search_dirs[*]}"):" in
            *:$(realpath "$dir"):*) ;;
            *) error_exit 1 "not a configured '$dir'" ;;
          esac
          DIR_KEYS=$dir
          ;;
        -) break ;;
        *) error_exit 1 "unknown option '$OPTARG'." ;;
      esac
      ;;
    h)
      usage
      exit 0
      ;;
    s) SUBCMD=show-script ;;
    n) DRY_RUN=true ;;
    q) QUIET=true ;;
    v) VERBOSE=$(($VERBOSE + 1))   ;;
    m) ALWAYS_USE_SCOPE=true ;;
    u) FORCE_CGROUP=true ;;
    t) # Accepts auto, default, cgroup-only or any known type
      value=$OPTARG
      [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
        USE_TYPE="${value,,}" ||
        USE_TYPE="$value"
      ;;
    c) USE_CGROUP="$OPTARG" ;;
    d) USE_TYPE="default" ;;
    z) USE_TYPE="cgroup-only" ;;
    k)
      kind=${OPTARG,,}
      kind=${kind%s}
      case "$kind" in
        rule | type | cgroup)
          SUBCMD=list
          LIST_KEYS=$kind
          ;;
        *) error_exit 1 "not a valid search key '${OPTARG}'." ;;
      esac
      ;;
    \?) error_exit 1 "unknown option '$OPTARG'." ;;
    :) error_exit 1 "missing argument for option '$OPTARG'." ;;
  esac
done #}}}
shift $(($OPTIND - 1))

case "$SUBCMD" in #{{{
  usage)
    usage
    exit 0
    ;;
  list)
    [ -z "$DIR_KEYS" ] &&
      get_keys "$LIST_KEYS" "${search_dirs[@]}" ||
      get_keys "$LIST_KEYS" "$DIR_KEYS"
    exit 0
    ;;
  rebuild)
    (cd $CACHEDIR && rm -f rules types cgroups)
    check_or_build_cache "yes"
    exit $?
    ;;
  *)
    [ $# -lt 1 ] &&
      usage &&
      exit 1
    ;;
esac #}}}

which "$1" &>/dev/null ||
  error_exit 1 "$1 not found"

cmd=$1
shift

# Save the command arguments, if any, for later
declare -ga my_args=("$@")

# TODO: Lock the runtime dir

# Purge old runtime files and check cache
find "${RUNTIMEDIR}/" -mindepth 1 -maxdepth 1 -type f -delete
check_or_build_cache

set +o errexit
set +o nounset

# Get commands
get_commands "$cmd"
ret=$?
if [ "$ret" -ne 0 ]; then
  error_exit "$ret" "$(<"$COMMANDS")"
fi
mapfile -t commands <"$COMMANDS"

if [ "${commands[0]}" != "commands" ]; then
  error_exit 1
fi

unset commands[0]

# TODO: Unlock the runtime dir

if [ "$SUBCMD" = "show-script" ]; then
  echo "#!/bin/bash"
  for cmdline in "${commands[@]}"; do
    eval set -- $cmdline
    [[ "$*" =~ ^exec.* ]] &&
      echo "$*" '"$@"' ||
      echo "$*"
  done
  exit 0
fi

bool $QUIET &&
  VERBOSE=0

if [ $UID -ne 0 ]; then
  user_or_system=--user
  sed_script='s/ ${user_or_system}/ --user/;'
else
  user_or_system=
  sed_script='s/ ${user_or_system}//;'
fi
sed_script+=' s/\$\$/'"$$"'/; s/ &>\/dev\/null//'

for cmdline in "${commands[@]}"; do
  [ -z "$cmdline" ] &&
    continue
  eval set -- $cmdline
  [[ "$*" =~ ^\[.* ]] &&
    continue
  cmd=($*)
  [[ "$*" =~ ^exec.* ]] &&
    cmd+=("${my_args[@]}")
  if [ $VERBOSE -ge 1 ] || bool $DRY_RUN; then
    sed "$sed_script" <<<"${PROG}: ${cmd[@]}" >&2
  fi
  bool $DRY_RUN &&
    continue
  eval "${cmd[@]}"
done

exit 0
