#!/bin/bash
# vim: set ft=sh fdm=marker ai ts=2 sw=2 tw=79 et:

set -o pipefail
set -o errtrace
set -o nounset
set -o errexit

PROG="nicy"

usage() { #{{{
  cat <<_EOF_
Usage:
  $PROG [(-q|-v)|-n|-s] [-t TYPE|-d|-z] [-c CGROUP|--cpu{QUOTA}] [-u] [-m] CMD [ARGS]…
  $PROG --rebuild
  $PROG -k (rules|types|cgroups) [--from-dir=DIR]

Options:
  -q, --quiet          Be quiet and suppress additional informational output.
  -v, --verbose        Be verbose and display which command is launched.
  -n, --dry-run        Display commands but do not run them.
  -s, --build-script   Build a script that replaces the current commandline,
                       excluding the final arguments, and display it.

  -t, --type=TYPE      Control the set of properties applied. Use 'auto' to sea-
                       rch for the command rule set (default), 'cgroup-only' to
                       remove any property except the cgroup, 'default' or an
                       other defined type TYPE.
  -d, --default        Like '--type=default'. Do not search for a rule.
                       Apply the fallback values from the 'default' type.
  -z, --cgroup-only    Like '--type=cgroup-only'. Unset all other properties.

  -c, --cgroup=CGROUP  Run the command as part of this existing CGROUP.
      --cpu{QUOTA}     Like '--cgroup=cpu{QUOTA}' where QUOTA is an integer that
                       represents a percentage relative to the total CPU time
                       available on all cores.

  -m, --managed        Always run the command in a transient scope.
  -u, --force-cgroup   Run the command as part of an existing cgroup, if any,
                       that matches properties found, when no other cgroup has
                       been set.

      --rebuild        Rebuild the cache and exit.

  -k, --keys=KIND      List known KIND keys.
      --from-dir=DIR   Limit keys search to configuration files from DIR folder.

  -h, --help           Display this help and exit.
_EOF_
} #}}}

error_exit() { #{{{
  echo -e "$PROG: error: ${2:-'unknown error'}" >&2
  exit "${1:-1}"
} #}}}

# The user 's configuration files always get the highest priority.
for dir in "/usr/local/etc" "/etc" "${XDG_CONFIG_HOME:-$HOME/.config}"; do
  [ ! -f "$dir/$PROG/environment" ] || . "$dir/$PROG/environment"
done

[ -v NICY_SEARCH_DIRS ] ||
  NICY_SEARCH_DIRS=("$HOME/.config/$PROG" "/etc/$PROG" "/usr/local/etc/$PROG")

[ -v NICY_DATADIR -a -d "$NICY_DATADIR" ] ||
  NICY_DATADIR="/usr/local/share/nicy"

bool() { #{{{
  [ $# -gt 0 ] || return 2
  case "${1,,}" in
    n | no | false | off | 0 | disabled | disabled | nouse) return 1 ;;
    y | yes | true | on | 1 | enabled | enable | use) return 0 ;;
  esac
  return 1
} #}}}

true_or_false() { #{{{
  bool "$1" &&
    echo "true" ||
    echo "false"
} #}}}

# Show what's going on
[ -v NICY_VERBOSE ] &&
  NICY_VERBOSE=$(true_or_false "$NICY_VERBOSE") ||
  NICY_VERBOSE=true

QUIET=false
VERBOSITY=0
bool "$NICY_VERBOSE" &&
  VERBOSITY=1
PRESET=auto
USE_CGROUP=null
PROBE_CGROUP=false
ALWAYS_USE_SCOPE=false
DRY_RUN=false
LIST_CATEGORY=
LIST_DIRECTORY=

SUBCMD=run

declare -ga search_dirs
for dir in "${NICY_SEARCH_DIRS[@]}"; do
  [ -d "$dir" ] && search_dirs+=($(realpath "$dir"))
done

RUNTIMEDIR="${XDG_RUNTIME_DIR:-/run/user/$UID}/$PROG"
[ -d "$RUNTIMEDIR" ] || mkdir -p "$RUNTIMEDIR"
CACHEDIR="${XDG_CACHE_HOME:-$HOME/.cache}/${PROG}"
[ -d "$CACHEDIR" ] || mkdir -p "$CACHEDIR"

CGROUPS="$CACHEDIR/cgroups"
TYPES="$CACHEDIR/types"
RULES="$CACHEDIR/rules"
DATABASE="$CACHEDIR/database"


# Functions

command -v jq &>/dev/null || error_exit 1 "$(command -V jq 2>&1)"
JQ_PATH=$(command -v jq)
jq() { $JQ_PATH -M "$@"; }

dump_content() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  [[ "$kind" =~ ^(cgroup|type|rule)$ ]] || return 2
  if [ "$kind" = "rule" ]; then
    depth="-mindepth 2"
    key="name"
  else
    depth="-maxdepth 1"
    key=$kind
  fi
  shift
  for confdir; do
    [ -d "$confdir" ] || continue
    find "${confdir}/" $depth -type f -iname "*.${kind}s" -print | sort -rn |
    xargs sed -E -s -e '/^\s*#/d' -e '/^$/d' \
      -e 's/("'"$key"'"\s*:)/"origin": "'"${confdir//\//\\\/}"'", \1/g'
  done
} #}}}

list() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  shift
  jqscript=$(printf 'include "nicy" ; dump("%s")' "$kind")
  jq -nr -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" \
    --args "$@" \
    |& tee "$volatile" \
    | column -t -s $'\t' | tail -n +2
} #}}}

dump_content_file_cache() { #{{{
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  jqscript=$(printf 'include "nicy" ; make_cache("%s")' "$kind")
  for confdir in "${search_dirs[@]}"; do
    dump_content "$kind" "$confdir" | jq -sc -L "$NICY_DATADIR" "$jqscript"
  done |& tee "$volatile"
} #}}}

build_json_cache() { #{{{
  jqargs=()
  pairs=($(printf '"%s":%s' "date" "$(date +"%s")"))
  for kind in "cgroup" "type" "rule"; do
    pairs+=($(printf '"%ss":$%ss' "$kind" "$kind"))
    var="${kind^^}S"
    jqargs+=(--slurpfile "${kind}s" "${!var}")
  done
  jqscript='{'"$( IFS=',' && echo "${pairs[*]}")"'}'
  jq -n "${jqargs[@]}" "$jqscript" >"$DATABASE"
} #}}}

check_or_build_cache() { #{{{
  # TODO: Provide environment variable to always rebuild cache
  do_rebuild=${1:-no}
  for kind in "cgroup" "type" "rule"; do
    var="${kind^^}S"
    dest=${!var}
    if [ ! -f "$dest" ] || bool $do_rebuild; then
      dump_content_file_cache "$kind" >"$dest"
    fi
  done
  if [ ! -f "$DATABASE" ] || bool $do_rebuild; then
    build_json_cache
  fi
} #}}}

find_cmd_path() { #{{{
  name=$(basename "$1")
  # Strip suffix, if any
  name=${name%.nicy}
  # Set an absolute path for the final command, trying to prevent loops (for
  # instance, with nested nicy invocations).
  pattern="^${NICY_SCRIPTS_PATH:-$HOME/bin/nicy}.*"
  # Not valid absolute path
  if [ "$1" = "$name" ] ||
    [[ "$(readlink -f $(which "$cmd"))" =~ $pattern ]]; then
    for path in $(which -a "$name"); do
      # Skip path that contains "nicy"
      [[ "$path" =~ $pattern ]] && continue
      cmd=$path
      break
    done
  else
    cmd=$1
  fi
  echo "$cmd"
} #}}}

jsonify() { #{{{
  case "$1" in
    [0-9]* | true | false | null) echo "$1" ;;
    *) echo '"'"$1"'"' ;;
  esac
} #}}}

QUERY_TEMPLATE='{
  "name": "%s",
  "cmd": "%s",
  "preset": "%s",
  "cgroup": %s,
  "probe_cgroup": %s,
  "managed": %s,
  "quiet": %s,
  "verbosity": %d,
  "shell": "%s",
  "nproc": %d,
  "max_nice": %d,
  "policies": {
    "sched": "%s",
    "io": "%s"
  }
}'

[ -v NICY_SHELL ] &&
  case "$NICY_SHELL" in
    /bin/sh | /bin/bash | /bin/zsh | \
      /usr/bin/sh | /usr/bin/bash | /usr/bin/zsh )
      SCRIPT_SHELL=$NICY_SHELL ;;
    *)
      SCRIPT_SHELL=/bin/sh ;;
  esac ||
  SCRIPT_SHELL=/bin/sh

build_query() { #{{{
  case "$1" in
    run)
      SCHED=$(LANG=C schedtool $$)
      IO=$(LANG=C ionice -p $$)
      ;;
    *)
      QUIET=true
      VERBOSITY=0
      SCHED="PID  0: PRIO   0, POLICY N: SCHED_NORMAL  , NICE   0, AFFINITY 0x1"
      IO="none: prio 0"
      ;;
  esac
  shift
  cmd=$(find_cmd_path "$1")
  printf "$QUERY_TEMPLATE" \
    "$(basename "$cmd")" \
    "$cmd" \
    "${PRESET}" \
    $(jsonify ${USE_CGROUP}) \
    ${PROBE_CGROUP} \
    ${ALWAYS_USE_SCOPE} \
    ${QUIET} \
    ${VERBOSITY} \
    "$(basename "$SCRIPT_SHELL")" \
    $(nproc --all) \
    $(ulimit -H -e) \
    "$SCHED" \
    "$IO"
} #}}}

COMMANDS="$RUNTIMEDIR/commands"

get_commands() { #{{{
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}"
  jqscript='include "nicy" ; main'
  cat - | tee "$volatile" | \
    jq -r -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" >"$COMMANDS" 2>&1
} #}}}

check_commands() { #{{{
  ret=$?
  [ "$ret" -ne 0 ] &&
    error_exit "$ret" "$(<"$COMMANDS")" ||
    true
  [ "$(read -r line <"$COMMANDS"; echo $line)" != "commands" ] &&
    error_exit 1 ||
    true
} #}}}

run_commands() { #{{{
  bool $QUIET &&
    VERBOSITY=0
  [ $UID -ne 0 ] &&
    sed_script='s/ ${user_or_system}/ --user/; s/$SUDO /'"$SUDO"' /;' ||
    sed_script='s/ ${user_or_system}//; s/$SUDO //;'
  sed_script+=' s/\$\$/'"$$"'/; s/ >\/dev\/null 2>&1//'
  for cmdline in "${commands[@]:1}"; do
    [ -z "$cmdline" ] &&
      continue
    eval set -- $cmdline
    [[ "$*" =~ ^\[.* ]] &&
      continue
    cmd=($*)
    [[ "$*" =~ ^exec.* ]] &&
      cmd+=("${cmdargs[@]}")
    if [ $VERBOSITY -ge 1 ] || bool $DRY_RUN; then
      sed "$sed_script" <<<"${PROG}: ${cmd[@]}" >&2
    fi
    bool $DRY_RUN &&
      continue
    eval "${cmd[@]}"
  done
} #}}}

dump_script() { #{{{
  echo "#!$SCRIPT_SHELL"
  for cmdline in "${commands[@]:1}"; do
    eval set -- $cmdline
    [[ "$*" =~ ^exec.* ]] &&
      echo "$*" '"$@"' ||
      echo "$*"
  done
} #}}}

do_lock() { #{{{
  count=3
  delay=1
  lockfile="$1/lock"
  while true; do
    let count--
    [ $count -le 0 ] && break
    [ ! -f "$lockfile" ] && break
    [ -f "$lockfile" ] && sleep $delay && continue
  done
  [ ! -f "$lockfile" ] &&
    echo "$$" >"$lockfile" &&
    return 0
  error_exit 128 "runtime folder locked by nicy (pid=$(<"$lockfile")) instance."
} #}}}

do_unlock() { #{{{
  [ -f "$1/lock" ] && rm "$1/lock" || true
} #}}}

# Parse options
OPTIND=1
while getopts ":-:hsnqvt:c:k:dzmu" option; do #{{{
  case $option in
    -)
      case "$OPTARG" in
        help)
          SUBCMD=usage
          break
          ;;
        rebuild)
          SUBCMD=rebuild
          break
          ;;
        dry-run) DRY_RUN=true ;;
        quiet) QUIET=true ;;
        verbose) VERBOSITY=$(($VERBOSITY + 1))   ;;
        type=*) # Accepts auto, default, cgroup-only or any known type
          value=${OPTARG#type=}
          [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
            PRESET="${value,,}" ||
            PRESET="$value"
          ;;
        cgroup=*) USE_CGROUP="${OPTARG#cgroup=}" ;;
        default) PRESET="default" ;;
        cgroup-only) PRESET="cgroup-only" ;;
        managed) ALWAYS_USE_SCOPE=true ;;
        force-cgroup) PROBE_CGROUP=true ;;
        cpu*) USE_CGROUP="$OPTARG" ;;
        build-script) SUBCMD=show ;;
        keys=*)
          kind=${OPTARG#keys=}
          kind=${kind,,}
          kind=${kind%s}
          case "$kind" in
            rule | type | cgroup)
              SUBCMD=list
              LIST_CATEGORY=$kind
              ;;
            *) error_exit 1 "not a valid category '${OPTARG##*=}'." ;;
          esac
          ;;
        from-dir=*)
          [ -z "$LIST_CATEGORY" ] &&
            error_exit 1 "missing required '--keys' option"
          dir=${OPTARG#from-dir=}
          dir=$(eval echo "$dir")
          [ ! -d "$dir" ] &&
            error_exit 1 "no such directory '$dir'"
          case ":$(IFS=: ; echo "${search_dirs[*]}"):" in
            *:$(realpath "$dir"):*) ;;
            *) error_exit 1 "not a configured '$dir'" ;;
          esac
          LIST_DIRECTORY=$dir
          ;;
        -) break ;;
        *) error_exit 1 "unknown option '$OPTARG'." ;;
      esac
      ;;
    h)
      usage
      exit 0
      ;;
    s) SUBCMD=show ;;
    n) DRY_RUN=true ;;
    q) QUIET=true ;;
    v) VERBOSITY=$(($VERBOSITY + 1))   ;;
    m) ALWAYS_USE_SCOPE=true ;;
    u) PROBE_CGROUP=true ;;
    t) # Accepts auto, default, cgroup-only or any known type
      value=$OPTARG
      [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
        PRESET="${value,,}" ||
        PRESET="$value"
      ;;
    c) USE_CGROUP="$OPTARG" ;;
    d) PRESET="default" ;;
    z) PRESET="cgroup-only" ;;
    k)
      kind=${OPTARG,,}
      kind=${kind%s}
      case "$kind" in
        rule | type | cgroup)
          SUBCMD=list
          LIST_CATEGORY=$kind
          ;;
        *) error_exit 1 "not a valid search key '${OPTARG}'." ;;
      esac
      ;;
    \?) error_exit 1 "unknown option '$OPTARG'." ;;
    :) error_exit 1 "missing argument for option '$OPTARG'." ;;
  esac
done #}}}
shift $(($OPTIND - 1))

case "$SUBCMD" in #{{{
  usage)
    usage
    exit 0
    ;;
  list)
    [ -z "$LIST_DIRECTORY" ] &&
      list "$LIST_CATEGORY" "${search_dirs[@]}" ||
      list "$LIST_CATEGORY" "$LIST_DIRECTORY"
    exit 0
    ;;
  rebuild)
    (cd $CACHEDIR && rm -f rules types cgroups)
    check_or_build_cache "yes"
    exit $?
    ;;
  *)
    [ $# -lt 1 ] &&
      usage &&
      exit 1
    ;;
esac #}}}

which "$1" &>/dev/null ||
  error_exit 1 "$1 not found"

cmd=$1
shift

# Save the command arguments, if any, for later use
declare -ga cmdargs=("$@")

# Lock the runtime dir
do_lock "$RUNTIMEDIR"

# Purge old runtime files and check cache
find "${RUNTIMEDIR}/" -mindepth 1 -maxdepth 1 -type f -delete
check_or_build_cache

# Set environment
NICY_SUDO=${NICY_SUDO:-sudo}
if [ $UID -ne 0 ]; then
  declare -x user_or_system=--user
  # Don't export SUDO when command is not allowed by policy
  sudo -l renice &>/dev/null &&
    declare -x SUDO=${NICY_SUDO} || true
else
  declare -x user_or_system=
  declare -x SUDO=
fi

# Get commands
case "$SUBCMD" in
  run) build_query run "$cmd" ;;
  show) build_query show "$cmd" ;;
  *) error_exit 1 ;;
esac |
  get_commands && check_commands
mapfile -t commands <"$COMMANDS"

# Unlock the runtime dir
do_unlock "$RUNTIMEDIR"

if [ "$SUBCMD" = "show" ]; then
  dump_script
  exit 0
fi

run_commands
exit 0
