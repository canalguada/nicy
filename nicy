#!/bin/bash
# vim: set ft=sh fdm=marker ai ts=2 sw=2 tw=79 noet:

shopt -s extglob

PROG="nicy"

# The user 's configuration files always get the highest priority.
for dir in "/usr/local/etc" "/etc" \
	"${XDG_CONFIG_HOME:-$HOME/.config}"; do
	[ -f "${dir}/${PROG}/environment" ] && . "${dir}/${PROG}/environment"
done
[ ${#NICY_SEARCH_DIRS[@]} -eq 0 ] &&
	NICY_SEARCH_DIRS=(
		"$HOME/.config/${PROG}"
		"/etc/${PROG}"
		"/usr/local/etc/{$PROG}"
	)

# Show what's going on
NICY_VERBOSE=${NICY_VERBOSE:-"n"}

QUIET=n
VERBOSE=0
[ "$NICY_VERBOSE" = "y" ] &&
	VERBOSE=1
USE_TYPE=auto
USE_CGROUP=null
FORCE_CGROUP=n
ALWAYS_USE_SCOPE=n
DRY_RUN=n
LIST_KEYS=
DIR_KEYS=

SUBCMD=exec

# Optional hard-coded color management #{{{
COLORS="n"
COLORG=
COLORR=
UNDERLINE=
RESET=
if [ -t 1 ] && [ "$COLORS" = "y" ]; then
	COLORR=$(tput setaf 1)
	COLORG=$(tput setaf 2)
	UNDERLINE=$(tput smul)
	RESET=$(tput sgr0)
fi #}}}

declare -ga search_dirs
for dir in "${NICY_SEARCH_DIRS[@]}"; do
	[ -d "$dir" ] && search_dirs+=("$dir")
done

CACHEDIR="${XDG_RUNTIME_DIR:-/run/user/$UID}/$PROG"
mkdir -p "$CACHEDIR"

usage() { #{{{
	cat <<-_EOF_
	Usage:
  $PROG [(-q|-v)|-n|-s] [-t TYPE|-d|-z] [-c CGROUP|--cpu{QUOTA}|-m] CMD [ARGS]…
  $PROG --rebuild
  $PROG -k (rules|types|cgroups) [--from-dir=DIR]

	Options:
  -q, --quiet          Be quiet and suppress additional informational output.
  -v, --verbose        Be verbose and display which command is launched.
  -n, --dry-run        Display commands but do not run them.
  -s, --build-script   Build a script that replaces the current commandline,
                       excluding the final arguments, and display it.

  -t, --type=TYPE      Control the set of properties applied. Use 'auto' to sea-
                       rch for the command rule set (default), 'cgroup-only' to
                       remove any property except the cgroup, 'default' or an
                       other defined type TYPE.
  -d, --default        Like '--type=default'. Do not search for a rule.
                       Apply the fallback values from the 'default' type.
  -z, --cgroup-only    Like '--type=cgroup-only'. Unset all other properties.

  -c, --cgroup=CGROUP  Run the command as part of this existing CGROUP.
      --cpu{QUOTA}     Like '--cgroup=cpu{QUOTA}' where QUOTA is a percentage
                       relative to the total CPU time available on all cores.
  -m, --managed        Run the command in a transient scope managed by a service
                       manage whether a cgroup has been set or not.
  -u, --force-cgroup   Run the command as part of the cgroup, if available, that
                       matches a relevant property found in rule, if a cgroup
                       has not been set yet.

      --rebuild        Rebuild the volatile cache and exit.

  -k, --keys=KIND      List known KIND keys.
      --from-dir=DIR   Limit keys search to configuration files from DIR folder.

  -h, --help           Display this help and exit.
	_EOF_
} #}}}

error_exit() { #{{{
	echo -e "${COLORR}$PROG: error: ${2:-'unknown error'}${RESET}" >&2
	exit "${1:-1}"
} #}}}

# Functions
has_cgroup() { systemctl list-unit-files --no-legend "${1}.slice" &>/dev/null ; }
has_cpuquota() { [ $# -eq 0 ] && return 1 || has_cgroup "cpu${1}" ; }

list_files() { #{{{
	[ $# -lt 2 ] && return 1
	kind=${1,,}
	kind=${kind%s}
	shift
	if [ "$kind" = "rule" ]; then
		for confdir; do
			[ ! -d "$confdir" ] && continue
			find "$confdir" -mindepth 1 -maxdepth 1 -type d -print | \
			sort -rg | while read -r dir; do
				find $dir/ -mindepth 1 -type f -iname "*.rules" -print | sort -rg
			done
		done
	elif [ "$kind" = "type" ] || [ "$kind" = "cgroup" ]; then
		for confdir; do
			[ ! -d "$confdir" ] && continue
			find $confdir/ -mindepth 1 -maxdepth 1 -type f -iname "*.${kind}s" -print | \
			sort -rg
		done
	fi
} #}}}

dump_content() { #{{{
	[ $# -lt 2 ] && return 1
	kind=${1,,}
	kind=${kind%s}
	shift
	list_files "$kind" "$@" | xargs sed -s '/^[ ]*#/d; /^$/d'
} #}}}

find_all()  { #{{{
	[ $# -ne 1 ] && return 1
	kind=${1,,}
	kind=${kind%s}
	dump_content "$kind" "${search_dirs[@]}"
} #}}}

unique_by() {
	[ $# -eq 0 ] && return 1
	key=$1
	jq -sMcr "unique_by(.$key) | .[] | .$key" -
}

get_keys()  { #{{{
	[ $# -lt 2 ] && return 1
	kind=${1,,}
	kind=${kind%s}
	case "$kind" in
		rule) key="name" ;;
		type | cgroup) key=$kind ;;
		*) return 1 ;;
	esac
	shift
	dump_content "$kind" "$@" | unique_by "$key"
} #}}}

make_json_cache()  { #{{{
	[ -z "$1" ] &&
		return 1
	kind=${1,,}
	kind=${kind%s}
	[[ "$1" =~ (rule|type|cgroup) ]] ||
		return 1
	dest="$CACHEDIR/${1}s"
	if [ ! -f "$dest" ]; then
		[ "$1" != "rule" ] &&
			key=$1 ||
			key="name"
		find_all "$1" | \
		jq -sMcr  '[.[]|map_values(tostring)]|unique_by(.'"$key"')|.[]' >"$dest"
	fi
} #}}}

check_or_build_cache () { #{{{
	for item in "rule" "type" "cgroup"; do
		make_json_cache "$item"
	done
} #}}}

set_filter()  { #{{{
	check_or_build_cache
	type_def="def type_def(\$t): \$types|first(.[]|select(.type == \$t))?;"
	cgroup_def="def cgroup_def(\$c): \$cgroups|first(.[]|select(.cgroup == \$c))? // {} ;"
	update_type='if has("type") then type_def(.type) + . else . end'
	update_cgroup='if has("cgroup") then cgroup_def(.cgroup) + . else . end'
	remove_keys='del(.name, .type)' # keep track of cgroup
	to_entries='to_entries|.[]|"\(.key)=\(.value)"'
	force_cgroup='if ($cgroup != "null") then . + cgroup_def($cgroup) else . end'
	default='type_def("default") // {}'
	case "$1" in
		auto) filter="\$rules|first(.[]|select(.name == \$name))? // ($default)" ;;
		default) filter="$default" ;;
		cgroup-only) filter="{}" ;;
		*) filter='type_def($type) // {}';;
	esac
	cat <<-EOF
	$type_def
	$cgroup_def
	$filter|
	$update_type|$update_cgroup|$force_cgroup|
	$remove_keys|$to_entries
	EOF
} #}}}

get_entries()  { #{{{
	set_filter "$USE_TYPE" >"$CACHEDIR/filter"
	jq --null-input -Mcr \
		--arg name "$1" \
		--arg cgroup "$USE_CGROUP" \
		--arg type "$USE_TYPE" \
		--slurpfile rules "$CACHEDIR/rules" \
		--slurpfile types "$CACHEDIR/types" \
		--slurpfile cgroups "$CACHEDIR/cgroups" \
		--from-file "$CACHEDIR/filter"
} #}}}

set_properties () { # {{{
	[ $# -ne 1 ] && return
	get_entries "$1" | while read -r option; do
		value=${option##*=}
		case "$option" in
			cgroup=*)
				# TODO: Cgroups values should be checked when parsing command-line
				# options (mostly done) and when updating the configuration files.
				# Add a switch to nicy command to parse and validate them.
				has_cgroup "$value" &&
					echo "USE_CGROUP=$value" ||
					error_exit 1 "not valid cgroup value '$value'." ;;
			CPUQuota=*) # percent, range 1..99
				# This property either belongs to some cgroup definition, either will
				# be applied through the transient scope.
				percent=${value%\%}
				[[ $percent -ge 1 ]] && [[ $percent -le 99 ]] &&
					echo "my_cpuquota=$percent" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			sched=*) # other, batch, idle, fifo or rr (man 2 sched_setscheduler)
				[[ "$value" =~ ^(other|fifo|rr|batch|idle)$ ]] &&
					echo "my_sched=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			rtprio=*) # range 1..99 (man 2 sched_setscheduler)
				[[ $value -ge 1 ]] && [[ $value -le 99 ]] &&
					echo "my_rtprio=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			nice=*) # range -20..19 (man 2 setpriority)
				[[ $value -ge -20 ]] && [[ $value -le 19 ]] &&
					echo "my_niceness=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			ioclass=*) # none, realtime, best-effort or idle (man 2 ioprio_set)
				[[ "$value" =~ ^(none|realtime|best-effort|idle)$ ]] &&
					echo "my_ioclass=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			ionice=*) # range 0..7 (man 2 ioprio_set)
				[[ $value -ge 0 ]] && [[ $value -le 7 ]] &&
					echo "my_ionice=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			oom_score_adj=*) # range -1000..1000
				[[ $value -ge -1000 ]] && [[ $value -le 1000 ]] &&
					echo "my_oomscoreadjust=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			# Some more options from man 5 systemd.resource-control
			IOWeight=*) # range 1..10000
				[[ $value -ge -1 ]] && [[ $value -le 10000 ]] &&
					echo "my_ioweight=$value" ||
					error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
			MemoryHigh=*|MemoryMax=*) # bytes (K, M, G and T suffix), percent or infinity
				case "$value" in
					infinity) ;;
					?([0-9])[0-9]?(%))
						[[ ${value%\%} -eq 0 ]] &&
							error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
					+([0-9])?(K|M|G|T))
						[[ ${value%[^[:digit:]]} -eq 0 ]] &&
							error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
					*)
						error_exit 1 "wrong '${option%%=*}' option: $value. Aborting." ;;
				esac
				echo "${option%%=*}=$value" ;;
			cmdargs=*)
				echo "my_cmdargs='$value'" ;;
		esac
	done
} #}}}

# Parse options
OPTIND=1
while getopts ":-:hsnqvt:c:k:dzmu" option; do #{{{
	case $option in
		-)
			case "$OPTARG" in
				help) SUBCMD=usage ; break ;;
				rebuild) SUBCMD=rebuild ; break ;;
				dry-run) DRY_RUN=y ;;
				quiet) QUIET=y ;;
				verbose) VERBOSE=$(( $VERBOSE + 1 )) ;;
				type=*) # Accepts auto, default, cgroup-only or any known type
					value=${OPTARG#type=}
					value=${value,,}
					if [[ "$value" =~ (auto|default|cgroup-only) ]]; then
						USE_TYPE="$value"
					else
						case "$(get_keys "types" "${search_dirs[@]}")" in
							*"$value"*) USE_TYPE="$value" ;;
							*) error_exit 1 "not valid type value '$value'." ;;
						esac
					fi
					;;
				cgroup=*)
					value=${OPTARG#cgroup=}
					value=${value,,}
					has_cgroup "$value" &&
						USE_CGROUP="$value" ||
						error_exit 1 "not valid cgroup value '$value'."
					;;
				default) USE_TYPE="default" ;;
				cgroup-only) USE_TYPE="cgroup-only" ;;
				managed) ALWAYS_USE_SCOPE=y ;;
				force-cgroup) FORCE_CGROUP=y ;;
				cpu*)
					has_cgroup "$OPTARG" &&
						USE_CGROUP="$OPTARG" ||
						error_exit 1 "unknown option '--$OPTARG'."
					;;
				build-script) SUBCMD=show-script ;;
				keys=*)
					kind=${OPTARG#keys=}
					kind=${kind,,}
					kind=${kind%s}
					case "$kind" in
						rule|type|cgroup)
							SUBCMD=list
							LIST_KEYS=$kind
							;;
						*) error_exit 1 "not valid keys value '${OPTARG##*=}'.";;
					esac
					;;
				from-dir=*)
					[ -z "$LIST_KEYS" ] &&
						error_exit 1 "missing required '--keys' option"
					dir=${OPTARG#from-dir=}
					dir=$(eval echo "$dir")
					[ -d "$dir" ] &&
						DIR_KEYS=$dir ||
						error_exit 1 "no such directory '$dir'"
					;;
				-) break ;;
				*) error_exit 1 "unknown option '$OPTARG'." ;;
			esac
		;;
		h)
			usage
			exit 0
			;;
		s) SUBCMD=show-script ;;
		n) DRY_RUN=y ;;
		q) QUIET=y ;;
		v) VERBOSE=$(( $VERBOSE + 1 )) ;;
		m) ALWAYS_USE_SCOPE=y ;;
		u) FORCE_CGROUP=y ;;
		t) # Accepts auto, default, cgroup-only or any known type
			case "$OPTARG" in
				auto|default|cgroup-only) USE_TYPE="$OPTARG" ;;
				# TODO: Check that type is valid
				*) USE_TYPE="$OPTARG" ;;
			esac
			;;
		c)
			has_cgroup "$OPTARG" &&
				USE_CGROUP="$OPTARG" ||
				error_exit 1 "not valid cgroup value '$OPTARG'."
			;;
		d) USE_TYPE="default" ;;
		z) USE_TYPE="cgroup-only" ;;
		k)
			kind=${OPTARG,,}
			kind=${kind%s}
			case "$kind" in
				rule|type|cgroup)
					SUBCMD=list
					LIST_KEYS=$kind
					;;
				*) error_exit 1 "not valid keys value '${OPTARG}'.";;
			esac
			;;
		\?) error_exit 1 "unknown option '$OPTARG'." ;;
		:) error_exit 1 "missing argument for option '$OPTARG'." ;;
	esac
done #}}}
shift $(($OPTIND - 1))

# [ $# -lt 1 ] &&
#   usage &&
#   exit 1

case "$SUBCMD" in
	usage)
		usage
		exit 0
		;;
	list)
		[ -z "$DIR_KEYS" ] &&
			get_keys "$LIST_KEYS" "${search_dirs[@]}" ||
			get_keys "$LIST_KEYS" "$DIR_KEYS"
		exit 0
		;;
	rebuild)
		(cd $CACHEDIR && rm -f rules types cgroups)
		check_or_build_cache
		exit $?
		;;
	*)
		[ $# -lt 1 ] &&
			usage &&
			exit 1
		;;
esac

unset my_quiet
([ "$QUIET" = "y" ] || [ $VERBOSE -lt 2 ]) &&
my_quiet="--quiet"
[ "$QUIET" = "y" ] &&
	VERBOSE=0

my_name=$(basename "$1")

# Prevent nasty loops if using nested nicy commands
pattern="${HOME}/.*nicy.*"
realpath=$(which "$1")
[ -z "$realpath" ] &&
	error_exit 1 "$1 not found"
realpath=$(readlink -f "$realpath")
if [ "$1" = "$my_name" ] || [[ "$realpath" =~ $pattern ]]; then
	# Strip suffix if any
	my_name=${my_name%.nicy}
	for realpath in $(which -a "$my_name"); do
		# Skip path that contains "nicy"
		[[ "$realpath" =~ $pattern ]] && continue
		cmdpath=$realpath
		break
	done
else
	cmdpath="$1"
fi
[ -z "$cmdpath" ] &&
	error_exit 1 "$1 not found" ||
	shift

# Properties
declare -g my_cpuquota my_sched my_rtprio my_niceness \
	my_ioclass my_ionice my_ioweight \
	my_oomscoreadjust my_memoryhigh my_memorymax \
	my_cmdargs

# Populate
eval $(set_properties "$my_name")

# Check if running the command in a scope is required
SCOPE_REQUIRED=n
if [ -v my_cpuquota ] || [ -v my_ioweight ] ||
	[ -v my_memoryhigh ] || [ -v my_memorymax ] ||
	[ "$ALWAYS_USE_SCOPE" = "y" ]; then
	SCOPE_REQUIRED=y
fi

# Command passed to `exec`, if no scope is required, or to `systemd-run`
declare -ga my_exec_cmd=("$cmdpath")

apply_renice () { #{{{
	if [ -v my_niceness ]; then
		# range -20..19 (man 2 setpriority)
		echo "ulimit -S -e $((20 - $my_niceness))"
		[ "$SCOPE_REQUIRED" = "n" ] &&
			echo "renice -n $my_niceness \$$ >/dev/null 2>&1"
	fi
} #}}}

apply_oomscore () { #{{{
	if [ -v my_oomscoreadjust ]; then
		# range -1000..1000
		cmd=("choom" "-n" "$my_oomscoreadjust")
		if [ "$SCOPE_REQUIRED" = "n" ]; then
			echo "${cmd[@]}" "-p \$$ >/dev/null 2>&1"
		else
			my_exec_cmd=("${cmd[@]}" "--" "${my_exec_cmd[@]}")
		fi
	fi
} #}}}

apply_schedtool () { #{{{
	# man 8 schedtool {{{
	# -N or -0
	#   set all PIDs to SCHED_NORMAL/OTHER
	# -F or -1
	#   to SCHED_FIFO   root-credentials required
	# -R or -2
	#   to SCHED_RR     root-credentials required
	# -B or -3
	#   to SCHED_BATCH
	# -I or -4
	#   to SCHED_ISO
	# -D or -5
	#   to SCHED_IDLEPRIO
	# -p prio
	#   specify  static  priority  required for SCHED_FIFO and SCHED_RR.
	#   Usually ranged from 1-99.
	# -n nice_level
	#   set the PID's nice level; see nice(2), nice(1).
	# -e command [arg ...]
	#   execute  command  with  given  scheduling parameters (overwrites
	#   schedtool's process image). See EXAMPLES.
	# -r     display min and max priority for each policy.
	# }}}
	sched_args=()
	if [ -v my_sched ]; then #{{{
		# other, batch, idle, fifo or rr (man 2 sched_setscheduler)
		case "$my_sched" in
			other) sched_args+=("-N") ;;
			fifo) sched_args+=("-F") ;;
			rr) sched_args+=("-R") ;;
			batch) sched_args+=("-B") ;;
			idle) sched_args+=("-D") ;;
		esac
	fi
	if [ -v my_rtprio ]; then
		if [ "$my_sched" = "fifo" ] || [ "$my_sched" = "rr" ] ||
			[[ "$(schedtool $$)" =~ '.* POLICY (F|R):.*' ]]; then
			sched_args+=("-p" "$my_prio")
		fi
	fi #}}}
	if [[ ${#sched_args[@]} -gt 0 ]]; then
		cmd=("schedtool" "${sched_args[@]}")
		if [ "$SCOPE_REQUIRED" = "n" ]; then
			echo "${cmd[@]}" "\$$ >/dev/null 2>&1"
		else
			my_exec_cmd=("${cmd[@]}" "-e" "${my_exec_cmd[@]}")
		fi
	fi
} #}}}

apply_ionice () { #{{{
	# man 1 ionice {{{
	# -c, --class class
	#        Specify the name or number of the scheduling class to use; 0 for
	#        none, 1 for realtime, 2 for best-effort, 3 for idle.
	#
	# -n, --classdata level
	#        Specify the scheduling class data.  This only has an  effect  if
	#        the  class  accepts  an argument.  For realtime and best-effort,
	#        0-7 are valid data (priority levels), and 0 represents the high‐
	#        est priority level.
	#
	# -p, --pid PID...
	#        Specify the process IDs of running processes for which to get or
	#        set the scheduling parameters.
	#
	# -P, --pgid PGID...
	#        Specify the process group IDs of running processes for which  to
	#        get or set the scheduling parameters.
	#
	# -t, --ignore
	#        Ignore  failure  to  set the requested priority.  If command was
	#        specified, run it even in case it was not possible  to  set  the
	#        desired  scheduling  priority,  which can happen due to insuffi‐
	#        cient privileges or an old kernel version.
	# }}}
	ionice_args=()
	if [ -v my_ioclass ]; then #{{{
		case "$my_ioclass" in
			none) ionice_args+=("-c" "0") ;;
			realtime) ionice_args+=("-c" "1") ;;
			best-effort) ionice_args+=("-c" "2") ;;
			idle) ionice_args+=("-c" "3") ;;
		esac
		# [ $my_ioclass -ge 0 ] && [ $my_ioclass -le 3 ] &&
		#   ionice_args+=("-c" "$my_ioclass")
	fi
	if [ -v my_ionice ]; then
		if [ "$my_ioclass" = "realtime" ] || [ "$my_ioclass" = "best-effort" ] ||
		[[ "$(LANG=C ionice -p $$)" =~ ^(realtime|best-effort): ]]; then
			ionice_args+=("-n" "$my_ionice")
		fi
	fi #}}}
	if [[ ${#ionice_args[@]} -gt 0 ]]; then
		cmd=("ionice" "-t" "${ionice_args[@]}")
		if [ "$SCOPE_REQUIRED" = "n" ]; then
			echo "${cmd[@]}" "-p \$$ >/dev/null 2>&1"
		else
			my_exec_cmd=("${cmd[@]}" "${my_exec_cmd[@]}")
		fi
	fi
} #}}}

complete_cmd () { #{{{
	if [ "$SCOPE_REQUIRED" = "y" ]; then
		cmd=("exec" "systemd-run" "-G" "-d" "$my_quiet")
		# No authentication for privileged operations.
		cmd+=("--no-ask-password")
		cmd+=("--scope" "--unit=$(basename "$my_name")-\$$")
		SLICE_IS_SET=n
		case "$USE_CGROUP" in
			cpu*)
				SLICE_IS_SET=y
				# Children in sub-hierarchy can't control 'cpu' cgroup controller.
				unset my_cpuquota
				;;
			mem*)
				SLICE_IS_SET=y
				# Children in sub-hierarchy can't control 'memory' cgroup controller.
				unset my_memoryhigh my_memorymax
				;;
			io*)
				SLICE_IS_SET=y
				# Children in sub-hierarchy can't control 'io' cgroup controller.
				unset my_ioweight
				;;
			*)
				if [ -v my_cpuquota ] && [ "$FORCE_CGROUP" = "y" ]; then
					# Find a cgroup definition matching required CPUQuota property
					filter='first(.[]|select(.CPUQuota == "'"$my_cpuquota"'"))?|.cgroup'
					cgroup=$(cat "${CACHEDIR}/cgroups" | jq -sMcr $filter)
					if [ -n "$cgroup" ]; then
						USE_CGROUP="$cgroup"
						SLICE_IS_SET=y
						unset my_cpuquota
					fi
				elif [ "$SLICE_IS_SET" = "n" ] &&
					[ -v my_memoryhigh ] && [ "$FORCE_CGROUP" = "y" ]; then
					# Find a cgroup definition matching required MemoryHigh property
					filter='first(.[]|select(.MemoryHigh == "'"$my_memoryhigh"'"))?|.cgroup'
					cgroup=$(cat "${CACHEDIR}/cgroups" | jq -sMcr $filter)
					if [ -n "$cgroup" ]; then
						USE_CGROUP="$cgroup"
						SLICE_IS_SET=y
						unset my_memoryhigh
					fi
				elif [ "$SLICE_IS_SET" = "n" ] &&
					[ -v my_memorymax ] && [ "$FORCE_CGROUP" = "y" ]; then
					# Find a cgroup definition matching required MemoryMax property
					filter='first(.[]|select(.MemoryMax == "'"$my_memorymax"'"))?|.cgroup'
					cgroup=$(cat "${CACHEDIR}/cgroups" | jq -sMcr $filter)
					if [ -n "$cgroup" ]; then
						USE_CGROUP="$cgroup"
						SLICE_IS_SET=y
						unset my_memorymax
					fi
				elif [ "$SLICE_IS_SET" = "n" ] &&
					[ -v my_ioweight ] && [ "$FORCE_CGROUP" = "y" ]; then
					# Find a cgroup definition matching required IOWeight property
					filter='first(.[]|select(.IOWeight == "'"$my_ioweight"'"))?|.cgroup'
					cgroup=$(cat "${CACHEDIR}/cgroups" | jq -sMcr $filter)
					if [ -n "$cgroup" ]; then
						USE_CGROUP="$cgroup"
						SLICE_IS_SET=y
						unset my_ioweight
					fi
				fi
				;;
		esac
		# Finally
		[ "$SLICE_IS_SET" = "y" ] &&
			cmd+=("--slice=${USE_CGROUP}.slice")
		[ $UID -ne 0 ] &&
			cmd+=("--user")
		# Add remaining properties to scope
		# In nicy, the quota value as a percentage of total CPU time for ALL cores
		if [ -v my_cpuquota ]; then
			value=$(( $(nproc --all) * $my_cpuquota ))
			cmd+=("-p" "CPUQuota=${value}%")
		fi
		[ -v my_ioweight ] &&
			cmd+=("-p" "IOWeight=$my_ioweight")
		[ -v my_memoryhigh ] &&
			cmd+=("-p" "MemoryHigh=$my_memoryhigh")
		[ -v my_memorymax ] &&
			cmd+=("-p" "MemoryMax=$my_memorymax")
		[ -v my_niceness ] &&
			cmd+=("--nice=$my_niceness")
	else
		cmd=("exec")
	fi
	if [ -v my_cmdargs ]; then
		mapfile -t args <<<"$(echo ${my_cmdargs:1:-1} |tr "," "\n")"
		my_exec_cmd+=("${args[@]}")
	fi
	echo "${cmd[@]}" "${my_exec_cmd[@]}"
} #}}}

[ -f "$CACHEDIR/commands" ] && rm -f "$CACHEDIR/commands"

exec 3<> "$CACHEDIR/commands"
apply_renice >&3
apply_oomscore >&3
apply_schedtool >&3
apply_ionice >&3
complete_cmd >&3
exec 3>&-
mapfile -t commands <"$CACHEDIR/commands"

quoted () { #{{{
	[ $# -gt 0 ] &&
		printf ' %q' "$@"
		# echo ${*@Q}
} #}}}

if [ "$SUBCMD" = "show-script" ]; then
	echo "#!/bin/bash"
	for cmdline in "${commands[@]}"; do
		[[ "$cmdline" =~ ^exec ]] &&
			echo "$cmdline" '"$@"' ||
			echo "$cmdline"
	done
	exit 0
fi

for cmdline in "${commands[@]}"; do
	[ -z "$cmdline" ] &&
		continue
	cmd=($(eval echo $cmdline))
	[[ "$cmdline" =~ ^exec ]] &&
		cmd+=("$@")
	([ $VERBOSE -ge 1 ] || [ "$DRY_RUN" = "y" ]) &&
		echo -e "${COLORG}${PROG}:$(quoted "${cmd[@]}")${RESET}" >&2
	[ "$DRY_RUN" = "y" ] &&
		continue
	"${cmd[@]}"
done

