#!/bin/bash
# vim: set ft=sh fdm=marker ai ts=2 sw=2 tw=79 et:

set -o pipefail
set -o errtrace
set -o nounset
set -o errexit

PROG="nicy"

# Utils {{{
error_exit() { #{{{
  echo -e "$PROG: error: ${2:-'unknown error'}" >&2
  exit "${1:-1}"
} #}}}

bool() { #{{{
  [ $# -gt 0 ] || return 2
  case "${1,,}" in
    n | no | false | off | 0 | disabled | disabled | nouse) return 1 ;;
    y | yes | true | on | 1 | enabled | enable | use) return 0 ;;
  esac
  return 1
} #}}}

true_or_false() { #{{{
  bool "$1" &&
    echo "true" ||
    echo "false"
} #}}}
#}}}

# Environment variables {{{
# The user 's configuration files always get the highest priority.
for dir in "/usr/local/etc" "/etc" "${XDG_CONFIG_HOME:-$HOME/.config}"; do
  [ ! -f "$dir/$PROG/environment" ] || . "$dir/$PROG/environment"
done

[ -v NICY_SEARCH_DIRS ] ||
  NICY_SEARCH_DIRS=("$HOME/.config/$PROG" "/etc/$PROG" "/usr/local/etc/$PROG")

[ -v NICY_DATADIR -a -d "$NICY_DATADIR" ] ||
  NICY_DATADIR="/usr/local/share/nicy"

[ -v NICY_VERBOSE ] &&
  NICY_VERBOSE=$(true_or_false "$NICY_VERBOSE") ||
  NICY_VERBOSE=true

declare -ga search_dirs
for dir in "${NICY_SEARCH_DIRS[@]}"; do
  [ -d "$dir" ] && search_dirs+=($(realpath "$dir"))
done

NICY_IGNORE="${NICY_SEARCH_DIRS[0]}/ignore"
NICY_SYMLINK="${NICY_SEARCH_DIRS[0]}/symlink"

supported_shell_or_die() { #{{{
  if [[ "$1" =~ (/usr|)/bin/(sh|bash|zsh) ]] &&
    grep -q "$1" /etc/shells; then
    echo "$1"
  else
    error_exit 1 "not a supported shell : $1"
  fi
} #}}}

[ -v NICY_SHELL ] &&
  SCRIPT_SHELL=$(supported_shell_or_die "$NICY_SHELL") ||
  SCRIPT_SHELL=/bin/sh

NICY_SUDO=${NICY_SUDO:-sudo}

# Don't export SUDO when commands are not allowed by policy
if [ $UID -ne 0 ] &&
  sudo -l renice &>/dev/null &&
  sudo -l schedtool &>/dev/null &&
  sudo -l ionice &>/dev/null; then
  declare -x SUDO=${NICY_SUDO} || true
else
  declare -x SUDO=
fi
#}}}

command -v jq &>/dev/null ||
  error_exit 1 "$(command -V jq 2>&1)"

JQ_PATH=$(command -v jq)
jq() { $JQ_PATH -M "$@"; }

# Usage {{{

# WIDTH=$COLUMNS
WIDTH=74

usage() { #{{{
  jqscript='include "usage"; main'
  jq -r -L "$NICY_DATADIR" "$jqscript" "${NICY_DATADIR}/usage.json" |
    fmt -s -w $WIDTH
} #}}}

jq_usage() { #{{{
  jqfunction="${FUNCNAME[1]%_usage}"
  jqscript=$(printf 'include "usage"; %s' "$jqfunction")
  jq -r -L "$NICY_DATADIR" "$jqscript" "${NICY_DATADIR}/usage.json" |
    fmt -s -w $WIDTH
} #}}}

run_usage() { jq_usage ; } 
show_usage() { jq_usage ; } 
list_usage() { jq_usage ; } 
install_usage() { jq_usage ; } 
rebuild_usage() { jq_usage ; } 
#}}}

# Runtime parameters {{{
QUIET=false
bool "$NICY_VERBOSE" &&
  VERBOSITY=1 ||
  VERBOSITY=0
PRESET=auto
USE_CGROUP=null
PROBE_CGROUP=false
ALWAYS_USE_SCOPE=false
DRY_RUN=false
LIST_CATEGORY=
LIST_DIRECTORY=
#}}}

# Global variables {{{
RUNTIMEDIR="${XDG_RUNTIME_DIR:-/run/user/$UID}/$PROG"
[ -d "$RUNTIMEDIR" ] || mkdir -p "$RUNTIMEDIR"
CACHEDIR="${XDG_CACHE_HOME:-$HOME/.cache}/${PROG}"
[ -d "$CACHEDIR" ] || mkdir -p "$CACHEDIR"

CGROUPS="$CACHEDIR/cgroups"
TYPES="$CACHEDIR/types"
RULES="$CACHEDIR/rules"
DATABASE="$CACHEDIR/database"
#}}}

# Functions

dump_content() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  [[ "$kind" =~ ^(cgroup|type|rule)$ ]] || return 2
  if [ "$kind" = "rule" ]; then
    depth="-mindepth 2"
    key="name"
  else
    depth="-maxdepth 1"
    key=$kind
  fi
  shift
  for confdir; do
    [ -d "$confdir" ] || continue
    find "${confdir}/" $depth -type f -iname "*.${kind}s" -print | sort -rn |
    xargs sed -E -s -e '/^\s*#/d' -e '/^$/d' \
      -e 's/("'"$key"'"\s*:)/"origin": "'"${confdir//\//\\\/}"'", \1/g'
  done
} #}}}

list() { #{{{
  [ $# -lt 2 ] && return 1
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  shift
  jqscript=$(printf 'include "nicy" ; dump("%s")' "$kind")
  jq -nr -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" \
    --args "$@" \
    |& tee "$volatile" \
    | column -t -s $'\t' | tail -n +2
} #}}}

dump_content_file_cache() { #{{{
  kind=${1,,}
  kind=${kind%s}
  volatile="$RUNTIMEDIR/${FUNCNAME[0]}-$kind"
  jqscript=$(printf 'include "nicy" ; make_cache("%s")' "$kind")
  for confdir in "${search_dirs[@]}"; do
    dump_content "$kind" "$confdir" | jq -sc -L "$NICY_DATADIR" "$jqscript"
  done |& tee "$volatile"
} #}}}

build_json_cache() { #{{{
  jqargs=()
  pairs=($(printf '"%s":%s' "date" "$(date +"%s")"))
  for kind in "cgroup" "type" "rule"; do
    pairs+=($(printf '"%ss":$%ss' "$kind" "$kind"))
    var="${kind^^}S"
    jqargs+=(--slurpfile "${kind}s" "${!var}")
  done
  jqscript='{'"$( IFS=',' && echo "${pairs[*]}")"'}'
  jq -n "${jqargs[@]}" "$jqscript" >"$DATABASE"
} #}}}

check_or_build_cache() { #{{{
  # TODO: Provide environment variable to always rebuild cache
  do_rebuild=${1:-no}
  for kind in "cgroup" "type" "rule"; do
    var="${kind^^}S"
    dest=${!var}
    if [ ! -f "$dest" ] || bool $do_rebuild; then
      dump_content_file_cache "$kind" >"$dest"
    fi
  done
  if [ ! -f "$DATABASE" ] || bool $do_rebuild; then
    build_json_cache
  fi
} #}}}

find_cmd_path() { #{{{
  name=$(basename "$1")
  # Strip suffix, if any
  name=${name%.nicy}
  # Set an absolute path for the final command, trying to prevent loops (for
  # instance, with nested nicy invocations).
  pattern="^${NICY_SCRIPTS_PATH:-$HOME/bin/nicy}.*"
  # Not valid absolute path
  if [ "$1" = "$name" ] ||
    [[ "$(readlink -f $(which "$cmd"))" =~ $pattern ]]; then
    for path in $(which -a "$name"); do
      # Skip path that contains "nicy"
      [[ "$path" =~ $pattern ]] && continue
      cmd=$path
      break
    done
  else
    cmd=$1
  fi
  echo "$cmd"
} #}}}

# QUERY_TEMPLATE
# {
#   "name": null,
#   "cmd": null,
#   "preset": null,
#   "cgroup": null,
#   "probe_cgroup": null,
#   "managed": null,
#   "quiet": null,
#   "verbosity": null,
#   "shell": null,
#   "nproc": null,
#   "max_nice": null,
#   "policies": {
#     "sched": null,
#     "io": null
#   }
# }

COMMANDS="$RUNTIMEDIR/commands"
FILTER="$RUNTIMEDIR/filter"

get_cmdlines() { #{{{
  case "$1" in
    run)
      SCHED=$(LANG=C schedtool $$)
      IO=$(LANG=C ionice -p $$)
      ;;
    *)
      QUIET=true
      VERBOSITY=0
      SCHED="PID  0: PRIO   0, POLICY N: SCHED_NORMAL  , NICE   0, AFFINITY 0x1"
      IO="none: prio 0"
      ;;
  esac
  shift
  cmd=$(find_cmd_path "$1")
  jqscript='include "nicy" ; main'
  jq -nr -L "$NICY_DATADIR" "$jqscript" \
    --argjson cachedb "$(<"$DATABASE")" \
    --args "$(basename "$cmd")" \
    "$cmd" \
    "${PRESET}" \
    "${USE_CGROUP}" \
    "${PROBE_CGROUP}" \
    "${ALWAYS_USE_SCOPE}" \
    "${QUIET}" \
    "${VERBOSITY}" \
    "$(basename "$SCRIPT_SHELL")" \
    "$(nproc --all)" \
    "$(ulimit -H -e)" \
    "$SCHED" \
    "$IO" >"$COMMANDS" 2>&1
  ret=$?
  [ "$ret" -ne 0 ] &&
    error_exit "$ret" "$(<"$COMMANDS")" ||
    true
  [ "$(read -r line <"$COMMANDS"; echo $line)" != "commands" ] &&
    error_exit 1 ||
    true
} #}}}

run_commands() { #{{{
  bool $QUIET &&
    VERBOSITY=0
  [ $UID -ne 0 ] &&
    sed_script='s/ ${user_or_system}/ --user/; s/$SUDO /'"$SUDO"' /;' ||
    sed_script='s/ ${user_or_system}//; s/$SUDO //;'
  sed_script+=' s/\$\$/'"$$"'/; s/ >\/dev\/null 2>&1//'
  for cmdline; do
    [ -z "$cmdline" ] &&
      continue
    eval set -- $cmdline
    [[ "$*" =~ ^\[.* ]] &&
      continue
    cmd=($*)
    [[ "$*" =~ ^exec.* ]] &&
      cmd+=("${cmdargs[@]}")
    if [ $VERBOSITY -ge 1 ] || bool $DRY_RUN; then
      sed "$sed_script" <<<"${PROG}: ${cmd[@]}" >&2
    fi
    bool $DRY_RUN &&
      continue
    eval "${cmd[@]}"
  done
} #}}}

dump_script() { #{{{
  echo "#!$SCRIPT_SHELL"
  for cmdline; do
    eval set -- $cmdline
    [[ "$*" =~ ^exec.* ]] &&
      echo "$*" '"$@"' ||
      echo "$*"
  done
} #}}}

remove_from_path() { #{{{
  case ":${PATH}:" in
    *":${1}:"*)
      export PATH=${PATH//$(sed 's/\//\\\//g' <<<"${1}"):/} ;;
    *) ;;
  esac
} #}}}

stream_scripts() { #{{{
  cat <<_EOF_ >"$FILTER"
include "nicy" ;
stream_scripts_from_rules("$1"; $(nproc --all); $(ulimit -H -e))
_EOF_
  jqargs=(
    --unbuffered
    -L "$NICY_DATADIR"
    -f "$FILTER"
    --argjson "cachedb" "$(<"$DATABASE")"
  )
  [ -s "$NICY_IGNORE" ] && jqargs+=(--args $(<"$NICY_IGNORE"))
  jq -nr "${jqargs[@]}" 2>&1 || error_exit 16 "unknown error with jq. Aborting."
} #}}}

write_scripts() { #{{{
  local -a script_lines
  local name="null"
  local dest="$SCRIPTS_PATH/${name}.nicy"
  while read -r line && [ -n "$line" ]; do
    case "$line" in
      begin*)
        name=${line##* }
        dest="$SCRIPTS_PATH/${name}.nicy"
        ;;
      end*)
        name_path=$(command -v "$name")
        if [ -n  "$name_path" ]; then
          for line in "${script_lines[@]}"; do
            eval set -- ${line//%$name%/$name_path}
            [[ "$*" =~ ^exec.* ]] &&
              echo "$*" '"$@"' ||
              echo "$*"
          done >"$dest"
          chmod +x "$dest"
        fi
        unset script_lines[@]
        ;;
      error*)
        read -r error_msg || true
        error_exit 32 "$error_msg"
        ;;
      *)
        script_lines+=("$line")
        ;;
    esac
  done
} #}}}

install_scripts() { #{{{
  # Create if required and remove from PATH
  [ -d "$SCRIPTS_PATH" ] ||
    mkdir -p "$SCRIPTS_PATH"
  remove_from_path "$SCRIPTS_PATH"

  # Delete nicy scripts but preserve all links
  find "${SCRIPTS_PATH}/" -type f -iname "*.nicy" -delete

  # Rebuild the json cache files
  check_or_build_cache "yes"

  # Create nicy script for all the rules matching an available command
  stream_scripts "$SCRIPT_SHELL" |&
  tee "$RUNTIMEDIR/stream_output" |
    write_scripts || true

  # Create links for all the command names provided by the user
  if [ -f "$NICY_SYMLINK" ]; then
    (
      cd "${SCRIPTS_PATH}"
      while read -r name; do
        [ ! -f "${name}.nicy" ] && rm -f "$name" && continue
        ln -sf -T "${name}.nicy" "$name"
      done <"$NICY_SYMLINK"
    )
  fi
} #}}}

do_lock() { #{{{
  count=3
  delay=1
  lockfile="$1/lock"
  while true; do
    let count--
    [ $count -le 0 ] && break
    [ ! -f "$lockfile" ] && break
    [ -f "$lockfile" ] && sleep $delay && continue
  done
  [ ! -f "$lockfile" ] &&
    echo "$$" >"$lockfile" &&
    return 0
  error_exit 128 "runtime folder locked by nicy (pid=$(<"$lockfile")) instance."
} #}}}

do_unlock() { #{{{
  [ -f "$1/lock" ] && rm "$1/lock" || true
} #}}}

# Parsing options

check_missing_argument() { #{{{
  case "$OPTARG" in
    -*) error_exit 1 "missing argument for option '-$option'." ;;
  esac
  return 0
} #}}}

parse_list_options() { #{{{
OPTIND=1
while getopts ":-:hf:" option; do #{{{
  case $option in
    -)
      case "$OPTARG" in
        help)
          list_usage
          exit 0
          ;;
        from=*)
          dir=${OPTARG#from=}
          dir=$(eval echo "$dir")
          [ ! -d "$dir" ] &&
            error_exit 1 "no such directory '$dir'"
          case ":$(IFS=: ; echo "${search_dirs[*]}"):" in
            *:$(realpath "$dir"):*) ;;
            *) error_exit 1 "not a configured '$dir'" ;;
          esac
          LIST_DIRECTORY=$dir
          ;;
        -) break ;;
        *) error_exit 1 "unknown option '--$OPTARG'." ;;
      esac
      ;;
    h)
      list_usage
      exit 0
      ;;
    f)
      check_missing_argument
      dir=$(eval echo "$OPTARG")
      [ ! -d "$dir" ] &&
        error_exit 1 "no such directory '$dir'"
      case ":$(IFS=: ; echo "${search_dirs[*]}"):" in
        *:$(realpath "$dir"):*) ;;
        *) error_exit 1 "not a configured '$dir'" ;;
      esac
      LIST_DIRECTORY=$dir
      ;;
    \?) error_exit 1 "unknown option '-$OPTARG'." ;;
    :) error_exit 1 "missing argument for option '-$OPTARG'." ;;
  esac
done #}}}
return $(($OPTIND - 1))
} #}}}

parse_install_options() { #{{{
OPTIND=1
while getopts ":-:h" option; do #{{{
  case $option in
    -)
      case "$OPTARG" in
        help)
          install_usage
          exit 0
          ;;
        -) break ;;
        *) error_exit 1 "unknown option '--$OPTARG'." ;;
      esac
      ;;
    h)
      install_usage
      exit 0
      ;;
    \?) error_exit 1 "unknown option '-$OPTARG'." ;;
    :) error_exit 1 "missing argument for option '-$OPTARG'." ;;
  esac
done #}}}
return $(($OPTIND - 1))
} #}}}

parse_run_or_show_options() { #{{{
  OPTIND=1
  while getopts ":-:hnqvp:c:dzmu" option; do #{{{
    case $option in
      -)
        case "$OPTARG" in
          help)
            [ "$subcmd" = "run" ] &&
              run_usage ||
              show_usage
            exit 0
            ;;
          dry-run)
            [ "$subcmd" = "run" ] &&
              DRY_RUN=true ||
              error_exit 1 "unknown option '--$OPTARG'."
            ;;
          quiet) QUIET=true ;;
          verbose) VERBOSITY=$(($VERBOSITY + 1)) ;;
          preset=*) # Accepts auto, default, cgroup-only or any known type
            value=${OPTARG#type=}
            [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
              PRESET="${value,,}" ||
              PRESET="$value"
            ;;
          cgroup=*) USE_CGROUP="${OPTARG#cgroup=}" ;;
          default) PRESET="default" ;;
          cgroup-only) PRESET="cgroup-only" ;;
          managed) ALWAYS_USE_SCOPE=true ;;
          force-cgroup) PROBE_CGROUP=true ;;
          cpu*) USE_CGROUP="$OPTARG" ;;
          -) break ;;
          *) error_exit 1 "unknown option '--$OPTARG'." ;;
        esac
        ;;
      h)
        [ "$subcmd" = "run" ] &&
          run_usage ||
          show_usage
        exit 0
        ;;
      n)
        [ "$subcmd" = "run" ] &&
          DRY_RUN=true ||
          error_exit 1 "unknown option '-$option'."
        ;;
      q) QUIET=true ;;
      v) VERBOSITY=$(($VERBOSITY + 1))   ;;
      m) ALWAYS_USE_SCOPE=true ;;
      u) PROBE_CGROUP=true ;;
      p) # Accepts auto, default, cgroup-only or any known type
        check_missing_argument
        value=$OPTARG
        [[ "${value,,}" =~ (auto|default|cgroup-only) ]] &&
          PRESET="${value,,}" ||
          PRESET="$value"
        ;;
      c) check_missing_argument && USE_CGROUP="$OPTARG" ;;
      d) PRESET="default" ;;
      z) PRESET="cgroup-only" ;;
      \?) error_exit 1 "unknown option '-$OPTARG'." ;;
      :) error_exit 1 "missing argument for option '-$OPTARG'." ;;
    esac
  done #}}}
  return $(($OPTIND - 1))
} #}}}

if [ $# -gt 0 ]; then
  subcmd=$1
  shift
else
  usage
  exit 1
fi

case "$subcmd" in
  help | -h | --help) #{{{
    usage
    exit 0
    ;; #}}}
  rebuild) #{{{
    if [ $# -eq 0 ]; then
      echo "Building nicy json cache..."
      (cd $CACHEDIR && rm -f rules types cgroups)
      check_or_build_cache "yes"
      rc=$?
      [ $rc -eq 0 ] &&
        echo "Done." ||
        echo "Error."
      exit $rc
    else
      rebuild_usage
      case "$1" in
        -h | --help) exit 0 ;;
        *) exit 1 ;;
      esac
    fi
    ;; #}}}
  run | show) #{{{
    parse_run_or_show_options "$@" || shift $?
    ;; #}}}
  list) #{{{
    parse_list_options "$@" || shift $?
    if [ -z "$1" ]; then
      list_usage
      error_exit 1 "missing category."
    else
      kind=${1,,}
      kind=${kind%s}
      case "$kind" in
        rule | type | cgroup) LIST_CATEGORY=$kind ;;
        *) error_exit 1 "not a valid category '$1'." ;;
      esac
    fi
    [ -z "$LIST_DIRECTORY" ] &&
      list "$LIST_CATEGORY" "${search_dirs[@]}" ||
      list "$LIST_CATEGORY" "$LIST_DIRECTORY"
    exit 0
    ;; #}}}
  install) #{{{
    parse_install_options "$@" || shift $?
    if [ $# -gt 0 ]; then
      SCRIPT_SHELL=$(supported_shell_or_die "$1")
      if [ $# -gt 1 ]; then
        SCRIPTS_PATH="$2"
      fi
    fi
    [ -v SCRIPT_SHELL ] ||
      SCRIPT_SHELL="/bin/sh"
    [ -v SCRIPTS_PATH ] ||
      SCRIPTS_PATH=${NICY_SCRIPTS_PATH:-$HOME/bin/nicy}
    echo -n "Installing scripts using '$SCRIPT_SHELL' to '$SCRIPTS_PATH'... "
    install_scripts
    echo "All done."
    exit 0
    ;; #}}}
  *)
    usage
    error_exit 1 "unknown subcommand '$subcmd'."
    ;;
esac

if [ $# -gt 0 ]; then
  which "$1" &>/dev/null ||
    error_exit 1 "$1 not found"
else
  usage
  error_exit 1 "missing command."
fi

name=$1
shift

# Save the command arguments, if any, for later use
declare -ga cmdargs=("$@")

# Lock the runtime dir
do_lock "$RUNTIMEDIR"

# Purge old runtime files and check cache
find "${RUNTIMEDIR}/" -mindepth 1 -maxdepth 1 -type f -delete
check_or_build_cache

# Set environment
[ $UID -ne 0 ] &&
  declare -x user_or_system=--user ||
  declare -x user_or_system=

# Get commands
case "$subcmd" in
  run | show) get_cmdlines "$subcmd" "$name" ;;
  *) error_exit 1 ;;
esac

mapfile -t cmdlines <"$COMMANDS"

# Unlock the runtime dir
do_unlock "$RUNTIMEDIR"

if [ "$subcmd" = "show" ]; then
  dump_script "${cmdlines[@]:1}"
  exit $?
fi

run_commands "${cmdlines[@]:1}"
exit $?
